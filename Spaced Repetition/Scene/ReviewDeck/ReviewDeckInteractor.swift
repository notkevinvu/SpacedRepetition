//
//  StudyDeckInteractor.swift
//  Spaced Repetition
//
//  Created by Kevin Vu on 4/24/20.
//  Copyright (c) 2020 An Nguyen. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ReviewDeckBusinessLogic {
    func sortCards(request: ReviewDeck.ConfigureData.Request)
    
    func showReviewOnboardingAlert(request: ReviewDeck.ShowReviewOnboardingAlert.Request)
    
    func showConfirmPopViewControllerAlert(request: ReviewDeck.FinishedReviewingDeck.Request)
    
    func showNoCardsToReviewAlert(request: ReviewDeck.NoCardsToReview.Request)
}

protocol ReviewDeckDataStore
{
    var deckInfo: Deck? { get set }
}

class ReviewDeckInteractor: ReviewDeckBusinessLogic, ReviewDeckDataStore, ReviewDeckViewDelegate
{
    
    // MARK: Properties
    var presenter: ReviewDeckPresentationLogic?
    var deckInfo: Deck?
    
    var cardBeingReviewed: Card?
    lazy var cardsToReview: [Card] = []
    /*
     TODO: Don't need retired cards here yet - in future, add an option for a
     'final review' which uses all cards, regardless of review status
     */
    
    
    // MARK: Sorting cards
    func sortCards(request: ReviewDeck.ConfigureData.Request) {
        guard let deckToReview = deckInfo else { return }
        
        let cardsFromDeck = deckToReview.cards.array as! [Card]
        
        for card in cardsFromDeck {
            /*
             if card does not have a 'last reviewed' date, it must be
             a new card that hasn't been reviewed yet. Thus, we should
             add it to the cardsToReview array. Then, we simply
             continue onto the next card - we add a dateLastReviewed Date
             when we actually review it (i.e. when the wrong/correct answer
             buttons are triggered)
            */
            guard let dateLastReviewed = card.dateLastReviewed else {
                cardsToReview.append(card)
                continue
            }
            
            let calendar = Calendar.current
            
            // we get the date at noon of both dates so we can check differences
            // in calendar day
            guard
                let formattedDateLastReviewed = calendar.date(bySettingHour: 12, minute: 0, second: 0, of: dateLastReviewed),
                let formattedCurrentDate = calendar.date(bySettingHour: 12, minute: 0, second: 0, of: Date())
                else {
                    continue
            }
            
            // compares the # of days between dateLastReviewed and current date
            let components = calendar.dateComponents([.day], from: formattedDateLastReviewed, to: formattedCurrentDate)
            
            guard let daysSinceLastReviewed = components.day else {
                assertionFailure("Couldn't get day count from dateComponents \(#line) - \(#file)")
                continue
            }
            
            
            switch card.reviewStatus {
            case Card.ReviewStatus.everyDay.rawValue:
                
                /*
                 Here, we check if the 'everyDay' card we are looking at has been
                 reviewed yesterday (that is, one calendar day ago). If it hasn't,
                 we continue to the next card to check its dateLastReviewed property.
                 If it has been a calendar day since, we pass the precondition check
                 and add it to the cardsToReview array.
                 */
                if daysSinceLastReviewed >= 1 {
                    cardsToReview.append(card)
                } else {
                    continue
                }
                
            case Card.ReviewStatus.everyTwoDays.rawValue:
                if daysSinceLastReviewed >= 2 {
                    cardsToReview.append(card)
                } else {
                    continue
                }
                
            case Card.ReviewStatus.everyThreeDays.rawValue:
                if daysSinceLastReviewed >= 3 {
                    cardsToReview.append(card)
                } else {
                    continue
                }
                
            case Card.ReviewStatus.onceAWeek.rawValue:
                if daysSinceLastReviewed >= 7 {
                    cardsToReview.append(card)
                } else {
                    continue
                }
                
            case Card.ReviewStatus.retired.rawValue:
                /*
                 TODO: Eventually we want to add a selection screen (action sheet?)
                 to ask users if they want to do their regular review (i.e. using
                 spaced repetition/leitner system) or do a final review for an
                 upcoming assessment (where all cards are added)
                 
                 Most likely still wouldn't do anything in this case/block though
                 */
                continue
            default:
                assertionFailure("Somehow card has a review status that is not one of the reviewStatus enum strings \(#line) - \(#file)")
                continue
            }
        }
        
        cardBeingReviewed = cardsToReview.first
        
        let response = ReviewDeck.ConfigureData.Response(firstCardToReview: cardBeingReviewed, numOfCardsToReview: cardsToReview.count, nameOfDeckBeingReviewed: deckToReview.name)
        presenter?.presentFirstCardAfterConfiguringData(response: response)
    }
    
    
    // MARK: Show review onboarding alert
    func showReviewOnboardingAlert(request: ReviewDeck.ShowReviewOnboardingAlert.Request) {
        let doneAction = AlertDisplayable.Action(title: "Ok!", style: .default, handler: nil)
        
        let viewModel = AlertDisplayable.ViewModel(title: "Using the review feature:", message: "Tap the card or the \"Flip card\" button to flip to the back side! \n\nPress the X or âˆš button to mark if you've gotten the card wrong or right! \n\nOnce you're finished, you'll be done until the next time you need to review! \n\nCards are separated into review cycles of: \n-Every day \n-Every 2 days \n-Every 3 days \n-Once a week \n-Retired (which means you probably don't need to review it anymore!)", textFields: [], actions: [doneAction])
        presenter?.presentAlert(viewModel: viewModel, alertStyle: .alert)
    }
    
    
    
    // MARK: Show confirm pop VC
    func showConfirmPopViewControllerAlert(request: ReviewDeck.FinishedReviewingDeck.Request) {
        let cancelAction = AlertDisplayable.Action(title: "Cancel", style: .cancel, handler: nil)
        
        let confirmAction = AlertDisplayable.Action(title: "Confirm", style: .default) { [weak self] (action, ac) in
            guard let self = self else { return }
            
            let response = ReviewDeck.FinishedReviewingDeck.Response()
            self.presenter?.presentFinishedReviewingDeck(response: response)
        }
        
        let viewModel = AlertDisplayable.ViewModel(title: "Leave review?", message: "Are you sure you want to leave while you're reviewing?", textFields: [], actions: [cancelAction, confirmAction])
        presenter?.presentAlert(viewModel: viewModel, alertStyle: .alert)
    }
    
    
    // MARK: No cards to review alert
    func showNoCardsToReviewAlert(request: ReviewDeck.NoCardsToReview.Request) {
        let confirmAction = AlertDisplayable.Action(title: "Done", style: .default) { [weak self] (action, ac) in
            guard let self = self else { return }
            
            let response = ReviewDeck.FinishedReviewingDeck.Response()
            self.presenter?.presentFinishedReviewingDeck(response: response)
        }
        
        let viewModel = AlertDisplayable.ViewModel(title: "All done!", message: "Good job! There aren't any cards to review for now. Please check again tomorrow!", textFields: [], actions: [confirmAction])
        presenter?.presentAlert(viewModel: viewModel, alertStyle: .alert)
    }
    
    
    // MARK: Delegate methods
    
    /*
     TODO (6/19):
     maybe configure the deckdetail scene such that card cells also show the review
     status
     */
    // MARK: Tapped wrong answer
    func didTapWrongAnswerButton() {
        cardBeingReviewed?.set(newReviewStatus: .everyDay, newDateLastReviewed: Date())
        
        do {
            try cardBeingReviewed?.managedObjectContext?.save()
        } catch let error as NSError {
            assertionFailure("Failed to update review status and date last reviewed for card being reviewed - \(#line) - \(#file) - error: \(error) with desc: \(error.userInfo)")
            return
        }
        
        guard !cardsToReview.isEmpty else {
            return
        }
        
        cardsToReview.removeFirst()
        cardBeingReviewed = cardsToReview.first
        
        let response = ReviewDeck.MoveToNextCard.Response(nextCardToReview: cardBeingReviewed)
        presenter?.presentNextCardToReview(response: response)
    }
    
    // MARK: Tapped correct answer
    func didTapCorrectAnswerButton() {
        
        switch cardBeingReviewed?.reviewStatus {
        // the card.set(newReviewStatus:) method has an internal call to save
        // managed context
            
        case Card.ReviewStatus.everyDay.rawValue:
            cardBeingReviewed?.set(newReviewStatus: .everyTwoDays, newDateLastReviewed: Date())
            
        case Card.ReviewStatus.everyTwoDays.rawValue:
            cardBeingReviewed?.set(newReviewStatus: .everyThreeDays, newDateLastReviewed: Date())
            
        case Card.ReviewStatus.everyThreeDays.rawValue:
            cardBeingReviewed?.set(newReviewStatus: .onceAWeek, newDateLastReviewed: Date())
            
        case Card.ReviewStatus.onceAWeek.rawValue:
            cardBeingReviewed?.set(newReviewStatus: .retired, newDateLastReviewed: Date())
            
        case Card.ReviewStatus.retired.rawValue:
            // Don't need to do anything for retired cards
            break
        default:
            assertionFailure("Somehow card had a non enum string \(#line) - \(#file)")
        }
        
        guard !cardsToReview.isEmpty else {
            return
        }
        
        cardsToReview.removeFirst()
        cardBeingReviewed = cardsToReview.first
        
        let response = ReviewDeck.MoveToNextCard.Response(nextCardToReview: cardBeingReviewed)
        presenter?.presentNextCardToReview(response: response)
    }
    
    // MARK: Finished progress bar
    func didFinishProgressBar() {
        
        deckInfo?.needsReview = false
        
        do {
            try deckInfo?.managedObjectContext?.save()
        } catch let error as NSError {
            assertionFailure("Failed to update deck's review status \(#line) - \(#file) - error: \(error) with desc: \(error.userInfo)")
        }
        
        let confirmFinishedReviewedDeckAction = AlertDisplayable.Action(title: "Confirm", style: .default) { [weak self] (action, ac) in
            
            guard let self = self else { return }
            
            let response = ReviewDeck.FinishedReviewingDeck.Response()
            self.presenter?.presentFinishedReviewingDeck(response: response)
        }
        
        let viewModel = AlertDisplayable.ViewModel(title: "Finished!", message: "You have finished reviewing this deck! Press \"Confirm\" to go back to see your cards.", textFields: [], actions: [confirmFinishedReviewedDeckAction])
        presenter?.presentAlert(viewModel: viewModel, alertStyle: .alert)
    }
    
}
